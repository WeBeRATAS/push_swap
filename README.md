# push_swap
Push_swap 42

Metodologia del programa Push_swap
===============================================
//Declara punteros a dos estructuras de datos/listas enlazadas, una para la pila `a` y otra para `b
	//Poner ambos punteros a NULL para evitar comportamientos indefinidos e indicar que empezamos con pilas vac√≠as

//Maneja los errores de recuento de entrada. El n√∫mero de argumentos debe ser 2 o m√°s, y la segunda entrada no debe estar vac√≠a.
	//Si hay errores de entrada, devuelve error

//Maneja ambos casos de entrada, ya sea un n√∫mero variable de argumentos de l√≠nea de comandos, o como una cadena
	//Si la entrada de n√∫meros es una cadena, llama a split() para dividir las subcadenas

//Inicializa la pila `a` a√±adiendo cada n√∫mero de entrada como un nodo a la pila `a`.
	//Maneja el desbordamiento de enteros, duplicados, y errores de sintaxis, por ejemplo, la entrada s√≥lo debe contener d√≠gitos, o signos `-` `+`.
		//Si se encuentran errores, libera la pila `a` y devuelve error
	//Comprueba para cada entrada, si es un entero largo
		//Si la entrada es una cadena, convertirla en un entero largo 
	//Agrega los nodos a la pila `a`.

//Comprueba si la pila `a` est√° ordenada
	//Si no est√° ordenada, implementa nuestro algoritmo de ordenaci√≥n 
		//Comprueba si hay 2 n√∫meros
			//Si es as√≠, simplemente intercambia los n√∫meros
		//Comprobar si hay 3 n√∫meros
			//Si es as√≠, implementa nuestro sencillo algoritmo sort three
		//Comprueba si la pila tiene m√°s de 3 n√∫meros
			//Si es as√≠, implanta nuestro algoritmo Turco (buscar referencias en internet) Hace el orden buscando el medio del stack y trabaja rotando 			con el valor que nos va definiendo.

//Limpia la pila


üî∑ Utilizar el comprobador proporcionado por 42
============================================================

    Descarga el archivo correcto de la p√°gina del tema, por ejemplo para Mac, o Linux, dentro del mismo directorio que tu ejecutable.
    Ejecutar el comprobador probablemente no funcionar√°, ya que no tendr√° el permiso del ejecutable. Compru√©balo escribiendo en el terminal ls -l
    Para darle permiso, haga chmod +x <nombredearchivo>.
    Pruebe su ejecutable con todo lo que necesitamos que haga nuestro push_swap:
        por ejemplo, las salidas correctas para todos los tipos de error
        por ejemplo, ejecute ARG="4 10 1 3 2"; ./push_swap $ARG | ./checker_Mac $ARG 
        Para ver cu√°ntas instrucciones, ejecute ARG="4 10 1 3 2"; ./push_swap $ARG | wc -l
        Para que nuestro programa pase la evaluaci√≥n, tendr√° que devolver n tama√±o de instrucciones para ordenar x n√∫mero de valores:
            Si x = 3 entonces n <= 3
            Si x = 5 entonces n <= 12
            Si x = 100 entonces n < 1500
            Si x = 500 entonces n < 11500
            Nota: cuantas menos instrucciones devuelva nuestro algoritmo, m√°s puntos de evaluaci√≥n obtendremos.

¬øQu√© es un algoritmo?
============================================

    Un conjunto de instrucciones para resolver un problema.


¬øQu√© es el concepto de complejidad?
====================================================

    An√°lisis de algoritmos: An√°lisis de las instrucciones paso a paso del algoritmo para comprender su rendimiento.
    Eficiencia del algoritmo: Observar la rapidez con la que un algoritmo resuelve un problema y los recursos que consume, como tiempo y memoria.
    Notaci√≥n asint√≥tica: Uso de notaciones matem√°ticas como Big O, Omega y Theta para analizar el tiempo de ejecuci√≥n de un algoritmo a medida que el problema aumenta de tama√±o.
    Complejidad temporal: Utilizando Big O, se observa el mejor, el peor y la media de los casos en que se completa un algoritmo.
    Complejidad espacial: Utilizando Big 0, se observa la cantidad de espacio de memoria que utiliza un algoritmo.

Solo se permiten estos movimientos:
=======================================

‚Ä¢ El objetivo es ordenar los n√∫meros del stack a en orden ascendente. Para hacerlo
tienes las siguientes operaciones a tu disposici√≥n:
*************************************************************************
sa swap a: Intercambia los dos primeros elementos del stack a. No hace nada si
hay uno o menos elementos.
sb swap b: Intercambia los dos primeros elementos del stack b. No hace nada si
hay uno o menos elementos.
ss swap a y swap b a la vez.
pa push a: Toma el primer elemento del stack b y lo pone el primero en el stack
a. No hace nada si b est√° vac√≠o.
pb push b: Toma el primer elemento del stack a y lo pone el primero en el stack
b. No hace nada si a est√° vac√≠o.
ra rotate a: Desplaza hacia arriba todos los elementos del stack a una posici√≥n,
de forma que el primer elemento se convierte en el √∫ltimo.
rb rotate b: Desplaza hacia arriba todos los elementos del stack b una posici√≥n,
de forma que el primer elemento se convierte en el √∫ltimo.
rr ra y rb al mismo tiempo.
rra reverse rotate a: Desplaza hacia abajo todos los elementos del stack a una
posici√≥n, de forma que el √∫ltimo elemento se convierte en el primero.
rrb reverse rotate b: Desplaza hacia abajo todos los elementos del stack b una
posici√≥n, de forma que el √∫ltimo elemento se convierte en el primero.
rrr rra y rrb al mismo tiempo.

El proyecto
Crea dos programas: checker y push_swap.
=========================================

El checker programa lee una lista aleatoria de n√∫meros enteros de la entrada est√°ndar, los almacena y comprueba si est√°n ordenados.

El push_swap programa calcula los movimientos para ordenar los n√∫meros enteros ( empujarlos, sacarlos, intercambiarlos y rotarlos entre la pila a y la pila b ) y muestra esas direcciones en la salida est√°ndar.

Puede ingresar push_swap a checker, y checker verificar√° que push_swaplas instrucciones de se hayan realizado correctamente.

Ambos programas deben analizar obligatoriamente la entrada en busca de errores, incluidas cadenas vac√≠as, ausencia de par√°metros, par√°metros no num√©ricos, duplicados e instrucciones no v√°lidas o inexistentes.

Push_Swap debe cumplir con la Norma 42.
Est√° estrictamente prohibido usar funciones normales . libc Sin embargo, los estudiantes pueden usar: write, read, malloc, free, exit. No debe tener fugas de memoria. Los errores deben manejarse con cuidado.
De ninguna manera puede cerrarse de manera inesperada (error de segmentaci√≥n, error de bus, doble liberaci√≥n, etc.).



